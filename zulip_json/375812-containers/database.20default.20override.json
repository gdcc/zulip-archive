[
    {
        "content": "<p>Being a newbie to the Dataverse code, it seems that Payara or some other service is configuring the default postgres database, is that correct?</p>",
        "id": 406786029,
        "sender_full_name": "kuhlaid",
        "timestamp": 1702050713
    },
    {
        "content": "<p>I am trying alter the database when Docker is setting up the postgres container but it seems the database may already be in use by the time Docker compose tries to attach the volume. For instance I have tried telling Docker compose to execute SQL on initialization of the container (such as running SQL scripts from within my local <code>/postgres/apiCleanCreate</code> directory for instance):</p>\n<blockquote>\n<p>volumes:</p>\n<div class=\"codehilite\"><pre><span></span><code>  - ./postgres/apiCleanCreate:/docker-entrypoint-initdb.d\n</code></pre></div>\n\n</blockquote>\n<p>I have tried using data-only database dumps and full create/clean database dumps, but they all fail since the database is already open. I'm guessing other services may be already using the database at this point, so I am trying to get some ideas as to how to achieve a database alteration on initialization. Any thoughts?</p>",
        "id": 406786644,
        "sender_full_name": "kuhlaid",
        "timestamp": 1702050907
    },
    {
        "content": "<p>I don't know if this helps or not, but here's an example or running a SQL script after the containers have been started: <a href=\"https://github.com/gdcc/api-test-runner/blob/5ee081923cf5f53d2f27b5f6918925ec6ebbecef/.github/workflows/develop.yml#L58\">https://github.com/gdcc/api-test-runner/blob/5ee081923cf5f53d2f27b5f6918925ec6ebbecef/.github/workflows/develop.yml#L58</a> (It's necessary to get certain API tests to pass.)</p>",
        "id": 406788892,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702051401
    },
    {
        "content": "<p>It seems like you're operating at an earlier and lower level, though?</p>",
        "id": 406789980,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702051637
    },
    {
        "content": "<p>Hmm. That script does not alter any existing tables or data so I'm not sure if it would work.</p>",
        "id": 406790942,
        "sender_full_name": "kuhlaid",
        "timestamp": 1702051920
    },
    {
        "content": "<p>Sure, but one should be able to run a SQL script against a running database. <code>psql -f update.sql</code> or whatever.</p>",
        "id": 406791325,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702052006
    },
    {
        "content": "<p>Typically we do this stuff in Flyway these days, but it should work.</p>",
        "id": 406791467,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702052038
    },
    {
        "content": "<p>Let me head back to the drawing board. I guess I need to figure out if I can use insert statements or if I need to upsert everything, and where foreign-keys will be a problem.</p>",
        "id": 406793382,
        "sender_full_name": "kuhlaid",
        "timestamp": 1702052452
    },
    {
        "content": "<p>Ok. I hope I'm not leading you astray. What does your SQL script do? What tables does it touch?</p>",
        "id": 406793927,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702052574
    },
    {
        "content": "<p>I guess, I'm thinking.... let's get the script working with <code>psql -f</code> first and then figure out where to put it longer term.</p>",
        "id": 406794598,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702052715
    },
    {
        "content": "<p>Question, when I dump the database (using <code>pg_dump --inserts...</code>) that Docker throws together, I get statements like <code>INSERT INTO public.dvobject </code>. However when I try t recompose a fresh build Docker using the data dumped (insert statements), Docker says <code>public.dvobject</code> does not exist.</p>",
        "id": 406800421,
        "sender_full_name": "kuhlaid",
        "timestamp": 1702054432
    },
    {
        "content": "<p>I'm probably confused, but wouldn't you restore with something like <code>psql mydb -f dump.sql</code>?</p>\n<p>I'm not sure what recompose means in this context.</p>\n<p>You've taken a dump of your database. Now you want to restore that dump to a fresh database? In our Docker setup?</p>",
        "id": 406801206,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702054715
    },
    {
        "content": "<p>Sorry, I am trying to use the Docker volume insert point within the Docker compose script (if possible). By recompose I mean clear out/delete the existing Docker containers and volumes and initiate a fresh compose. So at the moment I am not using the postgres restore command. My last test was to simply execute some insert statements (again through the compose volumes command) but for some reason the compose logs say <code>public.dvobject</code> (from the postgres insert statement) does not exist. I guess part of the problem is I do not know where the postgres database gets the default configuration from or when that executes in the Docker compose process. I'm assuming some other service (Payara?) is configuring the database?</p>",
        "id": 406811417,
        "sender_full_name": "kuhlaid",
        "timestamp": 1702058168
    },
    {
        "content": "<p>I'm not sure how it works in our containers, off the top of my head. In a classic installation, our Python script creates the database.</p>",
        "id": 406820701,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702061941
    },
    {
        "content": "<p>In our containers I'm pretty sure there's a fair amount of magic going on. MicroProfile Config stuff. I'm not exactly sure when or how the database gets created.</p>",
        "id": 406821865,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702062349
    },
    {
        "content": "<p>I have tried running database restore commands after the Dataverse bootstrapping is complete but they all fail. Since other services are attached to the database I don't believe the restore commands will work. Ideally this would happen within the postgres container before any other services attach to postgres. I'm not sure how I could go about decoupling the database setup from the bootstrapping so the database can be setup entirely within the postgres service.</p>",
        "id": 407233695,
        "sender_full_name": "kuhlaid",
        "timestamp": 1702298974
    },
    {
        "content": "<p>Would it be easy for me to reproduce what you're seeing? Would you like to provide scripts or specific commands?</p>",
        "id": 407240543,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702301460
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"598112\">@Philip Durbin</span>, I don't think it is worth it to try to duplicate the approach I was trying because it would not seem productive. Again, the database needs to be configured before services attach to it. The most useful thing would be to know is how the database is being created and configured by the bootstrapping service (or whichever service is handling it).</p>",
        "id": 407243349,
        "sender_full_name": "kuhlaid",
        "timestamp": 1702302467
    },
    {
        "content": "<p>Ok. Let's see if <span class=\"user-mention\" data-user-id=\"598183\">@Oliver Bertuch</span> can offer some insight into the Docker side.</p>",
        "id": 407244164,
        "sender_full_name": "Philip Durbin ðŸš€",
        "timestamp": 1702302724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598112\">Philip Durbin</span> <a href=\"#narrow/stream/375812-containers/topic/database.20default.20override/near/406821865\">said</a>:</p>\n<blockquote>\n<p>In our containers I'm pretty sure there's a fair amount of magic going on. MicroProfile Config stuff. I'm not exactly sure when or how the database gets created.</p>\n</blockquote>\n<p>No magic involved... A classic installation is using the same MPCONFIG things as our container... JPA is the one creating the tables if not existing. The underlying database is created by the Docker entrypoint scripts of the postgres image (names are taken from the provided env vars). See also \"Environment Variables\" at <a href=\"https://hub.docker.com/_/postgres\">https://hub.docker.com/_/postgres</a></p>",
        "id": 407903552,
        "sender_full_name": "Oliver Bertuch",
        "timestamp": 1702540570
    }
]